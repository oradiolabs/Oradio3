Legenda===================
T betekent TODO
R betekent reworked
V betekent rework akkoord
==========================

YYYY-MM-DD============================================================================================================================

WEBINTERFACE:
T - De web interface bestaat nu uit een collectie losse web pagina's.
    Nadeel is dat er veel duplicering van javascript en styling is tussen deze pagina's.
	Dit heeft als risico dat er (zinloze/onbegrijpelijke) verschillen insluipen voor de gebruiker.
	Het beste is om de web interface te refactoren naar Single Page Architecture (SPA).
	Bijkomend voordeel is ook dat de server, inclusief de fix voor issue #384, eenvoudiger wordt.

MPD:
T - Review mpd_control.py play method nav aanpassingen random nummer weergave
T - Review Documents/MPD/MPD_modules_description.docx
T - Olaf maakt test module mpd_control_test.py

2025-11-25============================================================================================================================

R - De singleton decorator vervangt de dedecated singleton code
R - De eigen debug print method is door oradio_log,debug() vervangen
R - De doc-strings en inline comments zij bijgewerkt

2025-11-24============================================================================================================================

play_system_sound.py:
Ik heb play_system_sound.py gereviewed.
Wat ik verwacht dat de module doet:
Als er een play(tune) aangeroepen wordt en er geen tune speelt en volume niet aangepast is:
  a. wordt volume van mpd en spotify verlaagd
  b. wordt afspelen van de gevraagde tune gestart
Als er een nieuwe play(tune) aangeroepen wordt terwijl de vorige tune nog afgespeeld:
  d. wordt afspelen van de vorige tune afgebroken, wordt afspelen van de nieuwe tune gestart
  e. wordt het volume van mpd en spotify geleidelijk weer naar oorspronkelijk volume teruggebracht
Als er een nieuwe play(tune) aangeroepen wordt terwijl de mpd en spotify volumeniveaus nog niet hersteld zijn:
  f. wordt het volume van mpd en spotify ingesteld op de waardes bij a)
  g. wordt afspelen van de vorige tune afgebroken, wordt afspelen van de nieuwe tune gestart
  h. wordt het volume van mpd (en spotify) geleidelijk weer naar oorspronkelijk volume teruggebracht

De huidige implementatie leest wat moeilijk omdat doc strings en inline comments niet overal aanwezig/compleet/duidelijk zijn. Maar wat ik ervan begrijp:
- De PlaySystemSound class is een singleton: Prima, maar kan beter de signleton decorator gebruiken ipv eigen implementatie
- De enige publieke method play(sound_key):
  - gebruikt een lock: Prima, thread-safe
  - zet mpd en spotify volumes
  - Start thread _play_sound_and_restore() die de sound_key af moet spelen
- De _play_sound_and_restore(sound_key) thread:
  - gebruikt een wrapper functie _play_sound(sound_key) die een aantal checks doet en dan via de shell de tune laat afspelen
  - de _resore_volumes() method aanroept om de mpd en spotify volumens geleidelijk terug op oorspronkelijk niveau te brengen
- De _restore_volumes() method start een thread _ramp_restore_volumes() die over een korte periode de mpd en spotify volumes herstelt
Om d) mogelijk te maken wordt bij elke play() call een nieuwe thread gestart die via _play_sound_and_restore() en _play_sound() via de shell de tune speelt. Er kunnen dus meerdere aplay commando's parallel gestart worden. Dar kan aplay tegen.
om e) / f) / h) mogelijk te maken is de volume instelling in de play afhandeling verweven met timers en events.
Het geheel oogt wat complex, maar doet wat het moet doen.

Dus wat mij betreft moet tenminste:
1. De singleton decorator gebruikt worden
2. De eigen debug print method door oradio_log vervangen worden
3. De doc-strings en inline comments een update krijgen

Ingrijpender, voor later, net als zaken als oradio_controls en web interface single page redesign, zou ik voorstellen om de volumeregeling te ontkoppelen van het afspelen van de tunes.
Dus play() niets anders laten doen dan de tune via aplay afspelen, met threads om overlap/override erin te houden.
Maar volumeregeling als een service te maken die volumes beheert op basis van of er wel/geen tunes afgespeeld worden

2025-11-10============================================================================================================================

GPIO:
Henk review: led_control.py
1 - GPIO zaken ontkoppelen uit led_control.py. De GPIO wordt zowel in led_control als in touch_buttons geinitialiseerd. 
    Zou op 1 plek moeten. Daarom GPIO zaken in een aparte module gpio_service.py afhandelen. 
    Daarbij een klasse aanbieden met config en set/get methodes. 
    Geeft betere abstractie door toevoeging van een hardware abstractie laag
2 - methodes turn_off_led(), turn_on_led(), turn_on_led_with_delay() moeten een True/False teruggeven
3 - delayed_off() thread gebruikt een sleep als delay.Beter is om een Timer thread te gebruiken
4 - control_blinking_led(self, led_name, cycle_time=None), graag de cycle_time parameter specificeren.
5 - De selftest is niet doelmatig. Beter is om  te testen of de leds ook werkelijk aan of uit staan door de GPIO status op te vragen van de geactiveerde led. 
    Hiermee test je of de leds werkelijk aan of uit staan.

2025-11-18============================================================================================================================

I2C:
V Review Documents/I2C/I2C_modules_description.docx
volume_control review:
V 1 - Ah, nu snap ik je. Reworked: AlsaVolume.set() VolumeControl._set_volume() geven nu True/False terug. Wordt in manager bewust genegeerd.
V 2 - De de exception komt als mixer_name niet bestaat, of initialisatie mislukt -> Extra comments toegevoegd aan AlsaVolume::__init__ in volumne_control.py
V 3 - raw_value range is niet beperkt, want wordt in method geclamped
V 4 - Ontbrekende foutmelding -> toegevoegd
V 5 - Zie punt 1
V 6 - Zie punt 1
V 7 - errors propageren nu niet, worden alleen gelogd. Zie issue #408
backligting.py review:
V 1 - Het is een vrij theoretisch geval: EEPROMS hebben een beperkt aantal write cycles.
      Nu wordt de EEPROM elke keer als Oradio en backlighting start geschreven.
	  Het is strikt genomen voldoende als dit eenmalig bij configuratie van Oradio gedaan wordt, dus in oradio_install.sh.
	  Maar omdat EEPROM schrijfbeperking bij 40-50000 cycles ligt hoeven we ons daar niet echt druk over te maken.
	  Kortom: we laten het in Backlighting::__init__ zitten. Eens?
V 2 - de stop() method docstring is niet correct: Stop the Backlight manager ipv volume control. Gecorrigeerd
i2c_service.py review:
V 1 - Reworked: een retry mechanisme voor write_byte() en write_block() toegevoegd
=> Review/Rework conclusie:
- volume_control.py rework is akkoord. Hiermee review afgesloten.
- backlighting.py rework is akkoord. Hiermee review afgesloten.
- i2c_service.py rework is akkoord: Hiermee review afgesloten

2025-11-10============================================================================================================================

MPD:
V 1 - Refactored code zit in trixie_mpd branch
V 2 - mpd_client singleton moet eruit
V 3 - Listener moet aparte singleton class worden
V 4 - functies die waarde retourneren maar deze genegeerd wordt moeten _ = <functie>  gebruiken om te laten zien dat negeren bewust is
V 5 - LET OP: bovenstaande heeft ook impact op radio_control.py en fastapi_server.py
V 6 - Probleem in _remove_song_when_finished(), met een if conditie waarbij een int() met een string vergeleken wordt: de "deleteid" wordt niet uitgevoerd
V 7 - Hetzelfde probleem in play_song(), ook een int()/String compare. Graag ook de single-line-code minder complex maken door meerdere code regels er aan te wijden. De code is dan beter leesbaar en te begrijpen. Ik heb voorbeeld toegevoegd.
V 8 - Probleem met twee self._execute() die bij elkaar gevoegd worden. Gaat fout als er None terugkomt==> TypeError
V 9 - Groene tekst als een module test optie een succes oplevert.
V 10 - Verhuis MPDBase naar eigen file mpd_base.py, laat mpd_control.p en mpd_monito.py die importeren
V 11 - Gebruik 'Singleton metaclass' in mpd_monitor.py (later ook in andere modules waar Singleton gebruikt wordt)
=> Review/Rework conclusie: Rework akkoord en hiermee MPD review afgesloten.
